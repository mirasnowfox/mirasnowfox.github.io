<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>A Winter's Tail — Mira's Diary</title>
<link rel="icon" type="image/svg+xml" href="assets/images/foxpaw.svg">
<link rel="apple-touch-icon" href="assets/images/foxpaw.svg">
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:sans-serif}
.stage{
  position:relative;
  width:100vw;

  height:100vh;   /* fallback (older browsers) */
  height:100dvh;  /* dynamic viewport height — mobile korrekt */

  overflow:hidden;
  opacity:0;
  transition:opacity 800ms ease;
}
  /* object-fit:contain (wie in deinem Original) */
  .stage img{position:absolute;left:0;top:0;width:100%;height:100%;object-fit:contain}
  /* schwarzes Overlay für Fade */
.fade{
  position:absolute;
  left:0;top:0;width:100%;height:100%;
  background:#000;
  opacity:0;
  /* deutlich langsamer + filmischere Kurve */
  transition: opacity 2200ms cubic-bezier(.22,1,.36,1);
  pointer-events:none;
  z-index:9999;
  will-change: opacity;
  -webkit-backface-visibility: hidden;
  backface-visibility: hidden;
}
  
  
  .hotspot{
  position:absolute;
  transform:translate(-50%,-50%);
  cursor:pointer;
  width:48px;
  height:48px;
  display:flex;
  align-items:center;
  justify-content:center;
}

.hotspot img{
  width:100%;
  height:100%;
  object-fit:contain;
  pointer-events:none;
  filter:
    brightness(0) invert(1)
    drop-shadow(0 0 6px rgba(255,255,255,0.7))
    drop-shadow(0 0 16px rgba(255,255,255,0.4));
  transition:transform 0.2s ease, filter 0.2s ease;
}

.hotspot:hover img{
  transform:scale(1.2);
  filter:
    brightness(0) invert(1)
    drop-shadow(0 0 8px rgba(255,255,255,0.9))
    drop-shadow(0 0 22px rgba(255,255,255,0.6));
}

.hotspot img{
  animation:pawIdle 3.5s ease-in-out infinite;
}

@keyframes pawIdle{
  0%{ transform:scale(1); }
  50%{ transform:scale(1.08); }
  100%{ transform:scale(1); }
}
  
  .core{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:12px;height:12px;border-radius:50%;background:#ff3b3b;box-shadow:0 0 0 8px rgba(255,59,59,.2)}
  
.label {
  position: absolute;
  left: 50%;
  bottom: 110%;
  transform: translateX(-50%) translateY(0);

  color: #fff;
  background: rgba(0, 0, 0, 0.88);

  padding: 6px 10px;
  border-radius: 6px;

  font-size: 13px;
  line-height: 1.3;

  white-space: nowrap;
  max-width: min(240px, 80vw);
  overflow-wrap: break-word;

  pointer-events: none;
  z-index: 5;

  opacity: 0;
  transition: opacity 0.2s ease, transform 0.2s ease;
  box-shadow: 0 4px 14px rgba(0,0,0,0.35);
}

/* wenn geflippt (unter Pfote) */
.label.flip {
  bottom: auto;
  top: 110%;
}

.label{
  opacity:0;
  transition:opacity 0.2s ease;
}

.hotspot:hover .label{
  opacity:1;
}
  
.boot-modal{
  position:fixed;
  inset:0;
  background:#000;
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:10001; /* über deinem .fade (9999) */
  opacity:1;
  transition:opacity 5000ms cubic-bezier(.4,0,.2,1); /* länger & filmischer */
}

.boot-modal.hide{
  opacity:0;
  pointer-events:none;
}

.boot-content{
  color:#fff;
  font-size:28px;
  letter-spacing:1px;
}


.stage.visible{
  opacity:1;
}

.confirm-modal{
  position:fixed;
  inset:0;
  background:#000;
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:11000;
  padding:2rem;
}

.confirm-box{
  background:#fff;
  padding:2rem;
  border-radius:8px;
  text-align:center;

  max-width:700px;
  width:90%;
  max-height:90dvh;
  overflow-y:auto;
}

.title-overlay{
  position:fixed;
  top:0;
  left:0;
  width:100vw;

  height:100vh;      /* Fallback */
  height:100dvh;     /* Korrekte mobile Viewport-Höhe */

  background:#000;
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:10001;

  opacity:0;
  pointer-events:none;
  transition:opacity 3500ms cubic-bezier(.22,1,.36,1);
}

.title-overlay.show{
  opacity:1;
  pointer-events:auto;
}
.title-overlay.hide{
  opacity:0;
  pointer-events:none;
}
.title-text{
  color:#fff;
  font-size:56px;
  letter-spacing:4px;

  text-align:center;
  width:100%;
}

.title-main {
  display: block;
  font-size: clamp(36px, 6vw, 72px);
  letter-spacing: 6px;
  text-transform: uppercase;
  color: #fff;

  text-shadow:
    0 0 6px rgba(255,255,255,0.9),
    0 0 18px rgba(255,255,255,0.6),
    0 0 36px rgba(255,255,255,0.25);
}

@keyframes titleGlow {
  0% {
    text-shadow:
      0 0 6px rgba(255,255,255,0.9),
      0 0 18px rgba(255,255,255,0.6),
      0 0 36px rgba(255,255,255,0.25);
  }
  50% {
    text-shadow:
      0 0 8px rgba(255,255,255,1),
      0 0 22px rgba(255,255,255,0.7),
      0 0 44px rgba(255,255,255,0.35);
  }
  100% {
    text-shadow:
      0 0 6px rgba(255,255,255,0.9),
      0 0 18px rgba(255,255,255,0.6),
      0 0 36px rgba(255,255,255,0.25);
  }
}

.title-main {
  animation: titleGlow 4s ease-in-out infinite;
}

.paw-button{
  width:72px;
  margin:30px auto 0;
  display:block;
  cursor:default;
  transition:filter 0.3s ease, transform 0.2s ease;
}

.paw-button.ready{
  animation:pawBreath 2.4s ease-in-out infinite;
  cursor:pointer;
}

/* Hover nur wenn ready */
.paw-button.ready:hover{
  transform:scale(1.1);
}

@keyframes pawBreath{
  0%{
    transform:scale(1);
    opacity:0.9;
  }
  50%{
    transform:scale(1.12);
    opacity:0.6;
  }
  100%{
    transform:scale(1);
    opacity:0.9;
  }
}


.paw-button{
  opacity:0.7;
  animation:pawBreath 2.4s ease-in-out infinite;
  cursor:pointer;
}

.paw-button:hover{
  transform:scale(1.1);
}

@keyframes pawBreath{
  0%{
    transform:scale(1);
    opacity:0.9;
  }
  50%{
    transform:scale(1.12);
    opacity:0.6;
  }
  100%{
    transform:scale(1);
    opacity:0.9;
  }
}


.stage,
.hotspot,
.hotspot img {
  user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
}

.hotspot img {
  -webkit-user-drag: none;
}

.hotspot.active .label {
  opacity: 1;
}

.stage {
  -webkit-touch-callout: none;
}

:fullscreen {
  background: #000;
}

:-webkit-full-screen {
  background: #000;
}


.hotspot.active img {
  transform: scale(1.15);
  filter:
    brightness(0) invert(1)
    drop-shadow(0 0 10px rgba(255,255,255,0.9))
    drop-shadow(0 0 28px rgba(255,255,255,0.6));
}

.hotspot.active .label {
  opacity: 1;
}

.title-overlay img {
  max-width: 90vw;
  height: auto;
  padding: 2rem;
  display: block;
}
</style>
</head>
<body>

<div class="confirm-modal" id="confirmModal">
  <div class="confirm-box">
<p>This is an interactive, explorable extension of my story <a href="https://www.deviantart.com/mirasnowfox/journal/A-Winter-s-Tail-Mira-s-Diary-1299810475" target="_blank" rel="noopener noreferrer"><em>“A Winter’s Tail (Mira’s Diary)”</em></a>.</p>

<p>You move through this world by clicking the marked points within each scene. Glowing paws indicate paths you can take. Paws marked with an “X” are not yet accessible.</p>

<p>All visuals were created with the help of AI and then carefully curated, refined, and composed by me. Each scene represents many hours of dedication and attention to detail.</p>

<p>I hope that wandering through these spaces brings you as much joy as creating this world has brought me.</p>

<p>This project is still a work in progress. Only a few scenes are complete so far, and not every path continues yet. Thank you for your patience as I continue expanding this world.</p>

<p><strong>Click the paw to begin.</strong></p>
	
<img src="assets/images/foxpaw.svg" class="paw-spinner paw-button" id="confirmBtn" alt="Enter the Realm">
	
  </div>
</div>

<div class="title-overlay" id="titleOverlay">

<img src="assets/images/title.png" alt="A Winter's Tale — Mira's Diary">

</div>

  <div class="stage" id="stage">
    <img id="scene" alt="Szene">
    <div class="fade" id="fade" aria-hidden="true"></div>
  </div>

<script>

const confirmBtn = document.getElementById('confirmBtn');
const isTouch = window.matchMedia("(hover: none)").matches;

/* helpers */
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}

/* Daten: Szenen / Hotspots (wie bei dir) */
let data = null;

async function loadData() {
  const response = await fetch('assets/json/scenes.json', {
    cache: 'no-cache'
  });

  if (!response.ok) {
    throw new Error(`HTTP Fehler: ${response.status}`);
  }

  data = await response.json();
}

/* Transition: fadeOut / change / fadeIn */
class Transition {

// in class Transition
constructor(el, opts = {}) {
  this.el = el;
  this.durationOut = opts.durationOut ?? 2200;
  this.durationIn  = opts.durationIn  ?? 1400;
  this._pendingCleanup = null; // <- für Cancel
}

_waitForTransition(timeout = 5000) {
  return new Promise(resolve => {
    // Falls vorher ein Listener/TImout hängt, entferne ihn jetzt
    if (this._pendingCleanup) {
      this._pendingCleanup();
      this._pendingCleanup = null;
    }

    let resolved = false;
    let timer = null;

const cleanup = () => {
  if (resolved) return;
  resolved = true;
  this.el.removeEventListener('transitionend', onEnd);
  if (timer) clearTimeout(timer);
  this._pendingCleanup = null; // <-- zusätzlich
};

    const onEnd = (ev) => {
      // akzeptiere opacity oder fehlenden propertyName (Browser-Varianten)
      if (ev.target === this.el && (ev.propertyName === 'opacity' || !ev.propertyName)) {
        cleanup();
        resolve();
      }
    };

    // Wenn kein sichtbarer Übergang (0s / 0ms) → sofort resolven
    const raw = getComputedStyle(this.el).transitionDuration || '';
    const first = (raw.split(',')[0] || '').trim();
    const seconds = parseFloat(first) || 0;
    if (!seconds) {
      resolve();
      return;
    }

    this.el.addEventListener('transitionend', onEnd);

    // setTimeout als Fallback, falls transitionend nicht kommt
    timer = setTimeout(() => {
      cleanup();
      resolve();
    }, timeout);

    // Handle zum späteren Abbrechen
    this._pendingCleanup = cleanup;
  });
}

cancelPending() {
  if (this._pendingCleanup) {
    this._pendingCleanup();
    this._pendingCleanup = null;
  }
}

  fadeOut() {
    // Dauer explizit für Out setzen
    this.el.style.transitionDuration = `${this.durationOut}ms`;
    this.el.style.pointerEvents = 'auto';

    // force a clean initial state then animate to fully opaque (Black frame)
    this.el.style.opacity = '0';
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        this.el.style.opacity = '1';
      });
    });

    return this._waitForTransition(this.durationOut + 300);
  }

fadeIn() {
  // Dauer für das Einblenden setzen
  this.el.style.transitionDuration = `${this.durationIn}ms`;

  // Interaktion sofort wieder erlauben
  this.el.style.pointerEvents = 'none';

  // Von Schwarz (opacity 1) zurück auf transparent (opacity 0)
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      this.el.style.opacity = '0';
    });
  });

  // Nur noch visuell auf das Ende warten
  return this._waitForTransition(this.durationIn + 300);
}
}

/* Engine: lädt Bilder, zeigt Hotspots, positioniert */
class Engine {

pruneCache() {

  while (this.preload.size > this.maxCacheSize) {

    const oldestKey = this.preload.keys().next().value;

    this.preload.delete(oldestKey);

  }

}

constructor(){
  this._loadToken = 0;
  this.stage = document.getElementById('stage');
  this.img = document.getElementById('scene');
  this.fade = document.getElementById('fade');
    
  this.isTouch = isTouch;

this.t = new Transition(this.fade, {
  durationOut: isTouch ? 3800 : 3200,
  durationIn:  isTouch ? 3800 : 3200
});

  this.current = null;
  this.preload = new Map();
  this.maxCacheSize = 20;

  window.addEventListener('resize', ()=> this.position());
  window.addEventListener('orientationchange', ()=> this.position());

  // visualViewport ist die präziseste API auf mobilen Browsern
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', ()=> this.position());
    window.visualViewport.addEventListener('scroll', ()=> this.position());
  }
}

async init(){
  await this.load(data.startScene, true);
    this.preloadNeighbours(this.current);
}

async load(id, first = false) {

  // Jede neue Szene bekommt eine neue ID
  const token = ++this._loadToken;
  this.t.cancelPending();

  const next = data.scenes[id];
  if (!next) return;

  // Falls gerade ein Fade läuft → sofort stoppen
  this.fade.style.transitionDuration = '0ms';
  this.fade.style.opacity = '0';
  this.fade.style.pointerEvents = 'none';

  // Browser muss Reset committen
  await new Promise(r => requestAnimationFrame(r));

  // ---- FADE OUT ----
  if (!first) {
    this.fade.style.transitionDuration = `${this.t.durationOut}ms`;
    this.fade.style.pointerEvents = 'auto';
    this.fade.style.opacity = '1';

    await this.t._waitForTransition(this.t.durationOut + 50);

    // Wenn inzwischen eine neue load() gestartet wurde → abbrechen
    if (token !== this._loadToken) return;
  }

  // ---- BILD SETZEN ----
  if (this.preload.has(id)) {
    const img = this.preload.get(id);
    this.preload.delete(id);
    this.preload.set(id, img);
    this.img.src = img.src;
  } else {
    this.img.src = 'assets/images/' + next.image;
  }

  // Warten bis Bild bereit ist
  try {
    await this.img.decode();
  } catch {}

  // Falls neue Szene gestartet wurde → abbrechen
  if (token !== this._loadToken) return;

  this.current = next;
  this.render();
  this.preloadNeighbours(next);

  // ---- FADE IN ----
  if (!first) {
    this.fade.style.transitionDuration = `${this.t.durationIn}ms`;
    this.fade.style.pointerEvents = 'none';
    this.fade.style.opacity = '0';

    await this.t._waitForTransition(this.t.durationIn + 50);

    if (token !== this._loadToken) return;
  }
}

  clear(){
    this.stage.querySelectorAll('.hotspot').forEach(e => e.remove());
  }
  
preloadNeighbours(scene) {

  scene.hotspots.forEach(h => {

    if (!h.target) return;

    if (this.preload.has(h.target)) return;

    const nextScene = data.scenes[h.target];
    if (!nextScene) return;

    const img = new Image();
    img.src = 'assets/images/' + nextScene.image;

    this.preload.set(h.target, img);

    this.pruneCache();

  });

}

  render(){
  document.querySelectorAll('.hotspot.active')
  .forEach(hs => hs.classList.remove('active'));
    this.clear();
    if(!this.current) return;
    for(const h of this.current.hotspots){
      const el = document.createElement('div');
      el.className = 'hotspot';
      el.dataset.hotspotId = h.id;
      el.style.zIndex = 1; // hotspots liegen unter dem fade-overlay (overlay blockiert bei active fade)
      
	  const icon = document.createElement('img');
	  icon.src = 'assets/images/foxpaw.svg';
	  el.appendChild(icon);
	  
      if(h.label){
        const label = document.createElement('div'); label.className='label'; label.textContent = h.label;
        el.appendChild(label);
      }


el.addEventListener('click', (ev) => {
  if (!h.target) return;

  // Desktop: sofort wechseln, keine .active-Animation
  if (!this.isTouch) {
    this.load(h.target);
    ev.stopPropagation();
    return;
  }

  if (el.classList.contains('active')) {
    ev.stopPropagation();
    return;
  }

  document.querySelectorAll('.hotspot.active').forEach(hs => hs.classList.remove('active'));
  el.classList.add('active');

this.load(h.target).catch(()=> el.classList.remove('active'));

  ev.stopPropagation();
});


      this.stage.appendChild(el);
    }
    // positioniere in nächster Frame um Bildmaße sicher zu haben
    requestAnimationFrame(()=> this.position());
  }

  /* berechnet Pixelposition eines Hotspots
     - h.x in [0..1] von links nach rechts
     - h.y in [0..1] von unten nach oben (wie gewünscht)
     berücksichtigt die tatsächliche Darstellung (object-fit:contain)
  */
position(){
  if(!this.current) return;
  // stage rect (sichtbare Fläche)
  
  const iw = this.img.naturalWidth;
  const ih = this.img.naturalHeight;
  
  if(!iw || !ih) return;   // ← WICHTIG
  
  const rect = this.stage.getBoundingClientRect();

  const stageW = rect.width;
  const stageH = rect.height;

  const scale = Math.min(stageW / iw, stageH / ih);

  const dispW = iw * scale;
  const dispH = ih * scale;

  const originX = rect.left + (stageW - dispW) / 2;
  const originY = rect.top  + (stageH - dispH) / 2;

  this.current.hotspots.forEach((h, i) => {
    const el = this.stage.querySelectorAll('.hotspot')[i];
    if(!el) return;

    const px = h.x * iw;
    const py_image = (1 - h.y) * ih;

    const px_s = px * scale;
    const py_s = py_image * scale;

    const cx = originX + px_s;
    const cy = originY + py_s;

    el.style.left = (cx - rect.left) + 'px';
    el.style.top  = (cy - rect.top) + 'px';

    const size = Math.max(28, Math.min(80, h.r * dispW));
	el.style.width = size + 'px';
	el.style.height = size + 'px';
  });
  
  // === TOOLTIP AUTO FLIP + EDGE CLAMP ===
const padding = 12;

this.stage.querySelectorAll('.hotspot').forEach(hotspot => {

  const label = hotspot.querySelector('.label');
  if (!label) return;

  // Reset state
  label.classList.remove('flip');
  label.style.transform = 'translateX(-50%)';

  // Tooltip sichtbar machen für Messung (unsichtbar aber messbar)
  const prevOpacity = label.style.opacity;
  label.style.opacity = '0';
  label.style.display = 'block';

  const rect = label.getBoundingClientRect();

  // 1. Oben kein Platz → flip nach unten
  if (rect.top < padding) {
    label.classList.add('flip');
  }

  // Neu messen nach Flip
  const rect2 = label.getBoundingClientRect();

  let shiftX = 0;

  // 2. Rechts clamp
  if (rect2.right > window.innerWidth - padding) {
    shiftX = window.innerWidth - padding - rect2.right;
  }

  // 3. Links clamp
  if (rect2.left < padding) {
    shiftX = padding - rect2.left;
  }

  label.style.transform = `translateX(calc(-50% + ${shiftX}px))`;

  label.style.opacity = prevOpacity;
});

}
  
  
}

/* Start */
(async function () {

  const confirmModal = document.getElementById('confirmModal');
  
  const titleOverlay = document.getElementById('titleOverlay');
  const stage        = document.getElementById('stage');

  // ENGINE SOFORT STARTEN (im Hintergrund!)
  
function requestFullscreenSafe(element) {
  if (element.requestFullscreen) {
    return element.requestFullscreen();
  } else if (element.webkitRequestFullscreen) { // Safari
    return element.webkitRequestFullscreen();
  } else if (element.msRequestFullscreen) { // old Edge
    return element.msRequestFullscreen();
  } else {
    return Promise.resolve(); // Fallback: nichts tun
  }
}

function exitFullscreenSafe() {
  if (document.exitFullscreen) {
    return document.exitFullscreen();
  } else if (document.webkitExitFullscreen) {
    return document.webkitExitFullscreen();
  } else if (document.msExitFullscreen) {
    return document.msExitFullscreen();
  }
}

confirmBtn.addEventListener('click', async () => {

  await requestFullscreenSafe(document.documentElement);
  confirmModal.remove();

  await loadData();

const engine = new Engine();
await engine.init();

  titleOverlay.classList.add('show');
  await new Promise(r => setTimeout(r, 2000));
  titleOverlay.classList.add('hide');
  await new Promise(resolve=>{
    titleOverlay.addEventListener('transitionend', resolve, { once:true });
  });
  titleOverlay.remove();

  stage.classList.add('visible');

  // Security: neu positionieren, nachdem Stage sichtbar ist
  // (kleines delay, damit Browser das Layout bestätigt)
  requestAnimationFrame(()=> requestAnimationFrame(()=> engine.position()));
});

})();
</script>
</body>
</html>